{
  "language": "Solidity",
  "sources": {
    "contracts/Go.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\ncontract Go {\n    error CallerNotAllowedToPlay();\n    error NotYourTurn();\n    error CannotPlayHere();\n    error OffBoard();\n    error MissingTwoConsecutivePass();\n    error NoLiberties();\n\n    uint public constant GOBAN = 19 * 19;\n    uint public constant WIDTH = 19;\n    uint public constant MAX_GROUP_SIZE = 100;\n\n    address public immutable white;\n    address public immutable black;\n    address public turn;\n\n    uint public capturedWhiteStones;\n    uint public capturedBlackStones;\n    bool public blackPassedOnce;\n    bool public whitePassedOnce;\n    int public blackScore;\n    int public whiteScore;\n\n    /**\n     * @dev Represents a single point on the Go board\n     * @param x The x coordinate\n     * @param y The y coordinate\n     * @param state The current state of this intersection (empty, black, or white)\n     */\n    struct Intersection {\n        uint x;\n        uint y;\n        State state;\n    }\n\n    Intersection[361] public intersections;\n\n    /**\n     * @dev Represents possible states of an intersection\n     */\n    enum State {\n        Empty,\n        Black,\n        White\n    }\n\n    event Start(string indexed statement);\n    event Move(string indexed player, uint indexed x, uint indexed y);\n    event End(string indexed statement, int indexed blackScore, int indexed whiteScore);\n    event Capture(string indexed player, uint indexed count);\n\n    /**\n     * @notice Initializes a new game of Go\n     * @dev Sets up the board and assigns players\n     * @param _white Address of the white player\n     * @param _black Address of the black player\n     */\n    constructor(address _white, address _black) {\n        white = _white;\n        black = _black;\n        turn = black;\n\n        uint i;\n        for (uint k; k < WIDTH; k++) {\n            for (uint j; j < WIDTH; j++) {\n                intersections[i++] = Intersection({x: j, y: k, state: State.Empty});\n            }\n        }\n        require(i == GOBAN, \"ERROR_DURING_GOBAN_INIT\");\n        emit Start(\"The game has started.\");\n    }\n\n    // Separate function for processing captures\n    function processCapture(uint[] memory group, State _opposingColor) private returns (uint) {\n        uint captureCount = 0;\n        for (uint j = 0; j < group.length && group[j] != 0; j++) {\n            if (intersections[group[j]].state == _opposingColor) {\n                intersections[group[j]].state = State.Empty;\n                captureCount++;\n            }\n        }\n        return captureCount;\n    }\n\n    // Modified capture processing\n    function processGroupCapture(uint[] memory group, State _opposingColor) private returns (uint) {\n        uint captureCount = 0;\n        bool[] memory processed = new bool[](GOBAN);\n\n        for (uint i = 0; i < group.length && group[i] != 0; i++) {\n            uint pos = group[i];\n            if (!processed[pos] && intersections[pos].state == _opposingColor) {\n                intersections[pos].state = State.Empty;\n                processed[pos] = true;\n                captureCount++;\n            }\n        }\n        return captureCount;\n    }\n\n    // Helper function to count group liberties\n    function countGroupLiberties(uint[] memory group) private view returns (uint) {\n        uint liberties = 0;\n        bool[] memory checkedPositions = new bool[](GOBAN);\n\n        for (uint i = 0; i < group.length && group[i] != 0; i++) {\n            (uint east, uint west, uint north, uint south) = getNeighbors(group[i]);\n\n            // Check each neighbor\n            if (east != 0 && !checkedPositions[east]) {\n                checkedPositions[east] = true;\n                if (intersections[east].state == State.Empty) liberties++;\n            }\n            if (west != 0 && !checkedPositions[west]) {\n                checkedPositions[west] = true;\n                if (intersections[west].state == State.Empty) liberties++;\n            }\n            if (north != 0 && !checkedPositions[north]) {\n                checkedPositions[north] = true;\n                if (intersections[north].state == State.Empty) liberties++;\n            }\n            if (south != 0 && !checkedPositions[south]) {\n                checkedPositions[south] = true;\n                if (intersections[south].state == State.Empty) liberties++;\n            }\n        }\n        return liberties;\n    }\n\n    function countLiberties(uint _position) public view returns (uint) {\n        uint liberties = 0;\n        (uint x, uint y) = positionToCoords(_position);\n\n        // Check each adjacent position\n        if (x + 1 < WIDTH && intersections[coordsToPosition(x + 1, y)].state == State.Empty) {\n            liberties++;\n        }\n        if (x > 0 && intersections[coordsToPosition(x - 1, y)].state == State.Empty) {\n            liberties++;\n        }\n        if (y + 1 < WIDTH && intersections[coordsToPosition(x, y + 1)].state == State.Empty) {\n            liberties++;\n        }\n        if (y > 0 && intersections[coordsToPosition(x, y - 1)].state == State.Empty) {\n            liberties++;\n        }\n\n        return liberties;\n    }\n\n    /**\n     * @notice Places a stone on the board\n     * @dev Handles turn logic, stone placement, and capture checking\n     * @param _x X coordinate\n     * @param _y Y coordinate\n     */\n    function play(uint _x, uint _y) public {\n        if (msg.sender != white && msg.sender != black) revert CallerNotAllowedToPlay();\n        if (isOffBoard(_x, _y)) revert OffBoard();\n\n        State playerColor = (msg.sender == white) ? State.White : State.Black;\n        address expectedTurn = (playerColor == State.White) ? white : black;\n        if (turn != expectedTurn) revert NotYourTurn();\n\n        uint move = getIntersectionId(_x, _y);\n        if (intersections[move].state != State.Empty) revert CannotPlayHere();\n\n        intersections[move].state = playerColor;\n\n        bool hasLiberties = countLiberties(move) > 0;\n        bool capturedOpponent = checkForCaptures(\n            move,\n            playerColor == State.White ? State.Black : State.White\n        );\n\n        if (!hasLiberties && !capturedOpponent) {\n            intersections[move].state = State.Empty;\n            revert NoLiberties();\n        }\n\n        turn = (msg.sender == white) ? black : white;\n\n        if (playerColor == State.White) {\n            whitePassedOnce = false;\n        } else {\n            blackPassedOnce = false;\n        }\n\n        emit Move(playerColor == State.White ? \"White\" : \"Black\", _x, _y);\n    }\n\n    /**\n     * @notice Allows a player to pass their turn\n     * @dev Two consecutive passes end the game\n     */\n    function pass() public {\n        if (msg.sender != white && msg.sender != black) revert CallerNotAllowedToPlay();\n\n        State playerColor = (msg.sender == white) ? State.White : State.Black;\n        address expectedTurn = (playerColor == State.White) ? white : black;\n        if (turn != expectedTurn) revert NotYourTurn();\n\n        if (msg.sender == white) {\n            whitePassedOnce = true;\n            turn = black;\n            emit Move(\"White\", 42, 42);\n        } else {\n            blackPassedOnce = true;\n            turn = white;\n            emit Move(\"Black\", 42, 42);\n        }\n\n        if (blackPassedOnce && whitePassedOnce) {\n            end();\n        }\n    }\n\n    // Helper function to validate coordinates\n    function isValidPosition(uint x, uint y) private pure returns (bool) {\n        return x < WIDTH && y < WIDTH;\n    }\n\n    // Helper functions for position conversions\n    function coordsToPosition(uint x, uint y) private pure returns (uint) {\n        require(x < WIDTH && y < WIDTH, \"Invalid coordinates\");\n        return y * WIDTH + x;\n    }\n\n    function positionToCoords(uint pos) private pure returns (uint x, uint y) {\n        require(pos < GOBAN, \"Invalid position\");\n        return (pos % WIDTH, pos / WIDTH);\n    }\n\n    function getNeighbors(\n        uint pos\n    ) public pure returns (uint east, uint west, uint north, uint south) {\n        (uint x, uint y) = positionToCoords(pos);\n\n        // Initialize all to 0\n        east = 0;\n        west = 0;\n        north = 0;\n        south = 0;\n\n        // Check each direction with boundary validation\n        if (x + 1 < WIDTH) {\n            east = y * WIDTH + (x + 1);\n        }\n        if (x > 0) {\n            west = y * WIDTH + (x - 1);\n        }\n        if (y + 1 < WIDTH) {\n            north = (y + 1) * WIDTH + x;\n        }\n        if (y > 0) {\n            south = (y - 1) * WIDTH + x;\n        }\n    }\n\n    function hasConnection(uint pos1, uint pos2) private view returns (bool) {\n        if (pos1 >= GOBAN || pos2 >= GOBAN) return false;\n        if (intersections[pos1].state != intersections[pos2].state) return false;\n        if (intersections[pos1].state == State.Empty) return false;\n\n        // Get coordinates\n        (uint x1, uint y1) = positionToCoords(pos1);\n        (uint x2, uint y2) = positionToCoords(pos2);\n\n        // Check if adjacent\n        return ((x1 == x2 && (y1 + 1 == y2 || y1 == y2 + 1)) ||\n            (y1 == y2 && (x1 + 1 == x2 || x1 == x2 + 1)));\n    }\n\n    function getGroup(uint _target) public view returns (uint[] memory) {\n        uint[] memory group = new uint[](MAX_GROUP_SIZE);\n        bool[] memory visited = new bool[](GOBAN);\n        uint groupSize = 0;\n\n        State targetState = intersections[_target].state;\n        if (targetState == State.Empty) {\n            return group;\n        }\n\n        // Create explicit stack for DFS\n        uint[] memory stack = new uint[](GOBAN);\n        uint stackSize = 1;\n        stack[0] = _target;\n\n        while (stackSize > 0) {\n            // Pop from stack\n            stackSize--;\n            uint currentPos = stack[stackSize];\n\n            if (!visited[currentPos]) {\n                visited[currentPos] = true;\n                group[groupSize++] = currentPos;\n\n                // Get the current stone's coordinates\n                (uint currentX, uint currentY) = getIntersection(currentPos);\n\n                // Explicitly check each direction and add connected stones of same color\n\n                // Check North\n                if (currentY < WIDTH - 1) {\n                    uint northPos = getIntersectionId(currentX, currentY + 1);\n                    if (!visited[northPos] && intersections[northPos].state == targetState) {\n                        stack[stackSize++] = northPos;\n                    }\n                }\n\n                // Check South\n                if (currentY > 0) {\n                    uint southPos = getIntersectionId(currentX, currentY - 1);\n                    if (!visited[southPos] && intersections[southPos].state == targetState) {\n                        stack[stackSize++] = southPos;\n                    }\n                }\n\n                // Check East\n                if (currentX < WIDTH - 1) {\n                    uint eastPos = getIntersectionId(currentX + 1, currentY);\n                    if (!visited[eastPos] && intersections[eastPos].state == targetState) {\n                        stack[stackSize++] = eastPos;\n                    }\n                }\n\n                // Check West\n                if (currentX > 0) {\n                    uint westPos = getIntersectionId(currentX - 1, currentY);\n                    if (!visited[westPos] && intersections[westPos].state == targetState) {\n                        stack[stackSize++] = westPos;\n                    }\n                }\n            }\n        }\n\n        return group;\n    }\n\n    function checkForCaptures(uint _movePosition, State _opposingColor) internal returns (bool) {\n        bool capturedAny = false;\n        bool[] memory processed = new bool[](GOBAN);\n        uint totalCaptured = 0;\n\n        // Get position coordinates\n        (uint x, uint y) = getIntersection(_movePosition);\n\n        // Create array to store groups we need to check\n        uint[] memory groupsToCheck = new uint[](4);\n        uint numGroups = 0;\n\n        // Add adjacent opposing stones to groups to check\n        if (x > 0) {\n            uint pos = getIntersectionId(x - 1, y);\n            if (intersections[pos].state == _opposingColor && !processed[pos]) {\n                groupsToCheck[numGroups++] = pos;\n                processed[pos] = true;\n            }\n        }\n        if (x < WIDTH - 1) {\n            uint pos = getIntersectionId(x + 1, y);\n            if (intersections[pos].state == _opposingColor && !processed[pos]) {\n                groupsToCheck[numGroups++] = pos;\n                processed[pos] = true;\n            }\n        }\n        if (y > 0) {\n            uint pos = getIntersectionId(x, y - 1);\n            if (intersections[pos].state == _opposingColor && !processed[pos]) {\n                groupsToCheck[numGroups++] = pos;\n                processed[pos] = true;\n            }\n        }\n        if (y < WIDTH - 1) {\n            uint pos = getIntersectionId(x, y + 1);\n            if (intersections[pos].state == _opposingColor && !processed[pos]) {\n                groupsToCheck[numGroups++] = pos;\n                processed[pos] = true;\n            }\n        }\n\n        // Check each group for capture\n        for (uint i = 0; i < numGroups; i++) {\n            uint[] memory group = getGroup(groupsToCheck[i]);\n            bool hasLiberties = false;\n\n            // Check group for liberties\n            for (uint j = 0; j < group.length && group[j] != 0; j++) {\n                uint pos = group[j];\n                if (countLiberties(pos) > 0) {\n                    hasLiberties = true;\n                    break;\n                }\n            }\n\n            // If no liberties, capture the group\n            if (!hasLiberties) {\n                uint captureCount = 0;\n                for (uint j = 0; j < group.length && group[j] != 0; j++) {\n                    uint pos = group[j];\n                    if (intersections[pos].state == _opposingColor) {\n                        intersections[pos].state = State.Empty;\n                        captureCount++;\n                    }\n                }\n                if (captureCount > 0) {\n                    capturedAny = true;\n                    totalCaptured += captureCount;\n                }\n            }\n        }\n\n        // Update capture count\n        if (totalCaptured > 0) {\n            if (_opposingColor == State.White) {\n                capturedWhiteStones += totalCaptured;\n            } else {\n                capturedBlackStones += totalCaptured;\n            }\n            emit Capture(_opposingColor == State.White ? \"White\" : \"Black\", totalCaptured);\n        }\n\n        return capturedAny;\n    }\n\n    function hasGroupLiberties(uint[] memory group) private view returns (bool) {\n        bool[] memory checked = new bool[](GOBAN);\n\n        for (uint i = 0; i < group.length && group[i] != 0; i++) {\n            (uint east, uint west, uint north, uint south) = getNeighbors(group[i]);\n\n            if (east != 0 && !checked[east] && intersections[east].state == State.Empty)\n                return true;\n            if (west != 0 && !checked[west] && intersections[west].state == State.Empty)\n                return true;\n            if (north != 0 && !checked[north] && intersections[north].state == State.Empty)\n                return true;\n            if (south != 0 && !checked[south] && intersections[south].state == State.Empty)\n                return true;\n\n            checked[group[i]] = true;\n        }\n        return false;\n    }\n\n    // Helper function for getGroup\n    function contains(uint[] memory arr, uint val, uint size) private pure returns (bool) {\n        for (uint i = 0; i < size; i++) {\n            if (arr[i] == val) return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Ends the game and calculates final scores\n     */\n    function end() private {\n        blackScore = 1; // TO DO: implement proper scoring\n        whiteScore = 0;\n        emit End(blackScore > whiteScore ? \"Black wins\" : \"White wins\", blackScore, whiteScore);\n    }\n\n    /**\n     * @notice Checks if coordinates are outside the board\n     * @param _a X coordinate\n     * @param _b Y coordinate\n     * @return bool True if position is off board\n     */\n    function isOffBoard(uint _a, uint _b) public pure returns (bool) {\n        return _a >= WIDTH || _b >= WIDTH;\n    }\n\n    /**\n     * @notice Converts x,y coordinates to a board position ID\n     * @param _a X coordinate\n     * @param _b Y coordinate\n     * @return uint Position ID\n     */\n    function getIntersectionId(uint _a, uint _b) public pure returns (uint) {\n        return _a + _b * WIDTH;\n    }\n\n    /**\n     * @notice Converts a board position ID to x,y coordinates\n     * @param _target Position ID\n     * @return _x X coordinate\n     * @return _y Y coordinate\n     */\n    function getIntersection(uint _target) public pure returns (uint _x, uint _y) {\n        return (_target % WIDTH, _target / WIDTH);\n    }\n\n    function getGameState()\n        external\n        view\n        returns (\n            Intersection[361] memory board,\n            address currentTurn,\n            uint256 whiteCaptured,\n            uint256 blackCaptured,\n            bool isWhitePassed,\n            bool isBlackPassed\n        )\n    {\n        return (\n            intersections,\n            turn,\n            capturedWhiteStones,\n            capturedBlackStones,\n            whitePassedOnce,\n            blackPassedOnce\n        );\n    }\n}\n"
    },
    "contracts/GoFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./Go.sol\";\n\ncontract GoFactory {\n    event GameCreated(\n        uint256 indexed gameId,\n        address indexed white,\n        address indexed black,\n        address gameAddress\n    );\n\n    uint256 public gameCount;\n    mapping(uint256 => address) public games;\n\n    function createGame(address white, address black) external returns (address) {\n        require(white != address(0) && black != address(0), \"Invalid player addresses\");\n        // require(white != black, \"Players must be different\");\n\n        Go newGame = new Go(white, black);\n        uint256 gameId = gameCount;\n        games[gameId] = address(newGame);\n\n        emit GameCreated(gameId, white, black, address(newGame));\n        gameCount++;\n\n        return address(newGame);\n    }\n\n    function getGame(uint256 gameId) external view returns (address) {\n        require(gameId < gameCount, \"Game does not exist\");\n        return games[gameId];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}